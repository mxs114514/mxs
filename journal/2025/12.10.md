# 📅 2025.12.10 全栈进阶：从“轮椅”到“拐杖”，手撸核心业务逻辑

> 🌤️ **心情/状态**：今天脱离了 AI 的“保姆式”投喂，开始尝试自己理解并重构代码。从 Prisma 数据建模到前端 Pinia 状态管理，再到路由架构调整，感觉自己终于摸到了全栈开发的门道。这种“知其然更知其所以然”的感觉，比单纯跑通代码更让人踏实。

## 💡 今日份“顿悟”

1.  **路由的本质区别**：
    以前总搞混前端路由和后端路由，今天彻底理清了：
    *   **前端路由 (Vue Router)**：管的是**“看什么”**。URL 变了，JS 换个组件渲染，浏览器不刷新。
    *   **后端路由 (Express Router)**：管的是**“拿什么”**。URL 变了，服务器返回不同的 JSON 数据。
    *   **面试话术**：前端路由是 SPA（单页应用）的导航仪，后端路由是 API 的分发器。

2.  **单一数据源 (Single Source of Truth)**：
    在做播放器状态持久化时，我深刻理解了 Pinia 的价值。
    *   **错误做法**：状态散落在 `<audio>` 标签、组件 data、localStorage 里，到处都要同步，乱成一锅粥。
    *   **正确做法**：Pinia 是唯一的“大脑”，`<audio>` 只是执行命令的“手脚”，localStorage 只是大脑的“备忘录”。所有状态变更必须走 Store 的 Action。

## 🧠 核心功能复现指南 (面试级详解)

### 1. 全栈开发流程 (Prisma + Express + Vue)
**场景**：实现一个“用户列表”功能。

*   **Step 1: 数据建模 (后端)**
    在 `schema.prisma` 定义模型，这是数据的源头。
    ```prisma
    model User {
      id       Int    @id @default(autoincrement())
      username String @unique
      role     String @default("user")
    }
    ```
    执行 `npx prisma db push` 同步数据库。

*   **Step 2: 接口开发 (后端)**
    在 `userController.ts` 中写逻辑，在 `index.ts` 注册路由。
    ```typescript
    // controller
    export const getUsers = async (req, res) => {
      const users = await prisma.user.findMany();
      res.json(users);
    };
    // router
    app.get('/api/users', getUsers);
    ```

*   **Step 3: 状态管理 (前端)**
    在 `stores/user.ts` 定义 Store。
    ```typescript
    export const useUserStore = defineStore('user', () => {
      const userList = ref([]);
      const fetchUsers = async () => {
        const res = await fetch('/api/users');
        userList.value = await res.json();
      };
      return { userList, fetchUsers };
    });
    ```

*   **Step 4: 视图渲染 (前端)**
    组件三部曲：Store -> Action -> Template。
    ```vue
    <script setup>
    const userStore = useUserStore();
    onMounted(() => userStore.fetchUsers());
    </script>
    <template>
      <div v-for="user in userStore.userList" :key="user.id">{{ user.username }}</div>
    </template>
    ```

### 2. 播放器状态持久化 (Pinia + LocalStorage)
**场景**：刷新页面后，歌曲能接着上次的进度播放。

*   **核心逻辑**：
    1.  **存**：监听切歌 (`watch`) 和页面关闭 (`beforeunload`)，将 `currentSong` 和 `currentTime` 存入 localStorage。
    2.  **取**：Store 初始化时 (`restoreState`) 读取 localStorage。
    3.  **同步**：利用 `<audio>` 的 `loadedmetadata` 事件，在音频元数据加载完成后，立即设置 `currentTime`。

*   **关键代码 (Store)**：
    ```typescript
    // 保存状态
    const saveState = () => {
      localStorage.setItem('player-state', JSON.stringify({
        song: currentSong.value,
        time: currentTime.value
      }));
    };

    // 恢复状态
    const restoreState = () => {
      const saved = localStorage.getItem('player-state');
      if (saved) {
        const { song, time } = JSON.parse(saved);
        currentSong.value = song;
        currentTime.value = time; // 恢复进度变量
      }
    };

    // 自动保存策略
    watch(currentSong, saveState); // 切歌存
    window.addEventListener('beforeunload', saveState); // 关窗存
    restoreState(); // 启动取
    ```

*   **关键代码 (组件)**：
    ```vue
    <audio
      ref="audioRef"
      @timeupdate="(e) => playerStore.currentTime = e.target.currentTime" <!-- DOM -> Store -->
      @loadedmetadata="audioRef.currentTime = playerStore.currentTime"    <!-- Store -> DOM (断点续传) -->
    ></audio>
    ```

### 3. 每日推荐 (前端算法 + 缓存)
**场景**：每天展示 10 首随机歌曲，当天刷新不变，第二天自动刷新。

*   **实现原理**：
    1.  **检查缓存**：对比 `localStorage` 里的日期和今天是否一致。
    2.  **一致**：直接用缓存里的 ID 列表去 Store 里找歌。
    3.  **不一致**：执行洗牌算法，生成新列表，存入缓存。

*   **关键代码**：
    ```typescript
    const generateDailyRecommend = () => {
      const today = dayjs().format('YYYY-MM-DD');
      const cachedDate = localStorage.getItem('daily_date');

      if (cachedDate !== today) {
        // 洗牌算法：随机排序后取前10
        const randomSongs = [...songList.value]
          .sort(() => 0.5 - Math.random())
          .slice(0, 10);
        
        // 更新缓存
        localStorage.setItem('daily_date', today);
        localStorage.setItem('daily_ids', JSON.stringify(randomSongs.map(s => s.id)));
        recommendSongs.value = randomSongs;
      } else {
        // 走缓存逻辑...
      }
    };
    ```

### 4. 全局播放器架构 (Layout 提升)
**场景**：切换路由（如从首页进专辑页），音乐不中断。

*   **问题根因**：
    原结构中，播放器组件 (`AppFooterPlayerBar`) 放在各个页面 (`HomeView`) 内部。路由切换会导致页面销毁 -> 播放器销毁 -> 音乐停止。

*   **解决方案**：
    将播放器提升到 `App.vue` 或全局 Layout 中，包裹 `RouterView`。

*   **架构变更**：
    ```vue
    <!-- App.vue (新结构) -->
    <template>
      <BasicLayout>
        <!-- 播放器在这里，永远不销毁 -->
        <RouterView /> <!-- 只有这里的内容在变 -->
      </BasicLayout>
    </template>
    ```

## 🚀 接下来我要做什么（Action Items）
- [ ] **[歌词同步]**：研究一下如何解析 `.lrc` 文件，并结合 `currentTime` 实现歌词滚动。
- [ ] **[虚拟列表]**：如果歌曲列表达到上千首，渲染会卡顿，准备学习一下虚拟滚动技术。
- [ ] **[鉴权系统]**：完善后端的 JWT 登录验证，给上传接口加上权限锁。

## 💭 碎碎念
今天的重构让我明白，写代码不能只顾着“能跑就行”。合理的架构（如单一数据源、组件层级设计）虽然前期麻烦点，但能省去后期无数的 Debug 时间。这就是“慢即是快”吧。
