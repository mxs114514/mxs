# 📅 2025.11.27 交互进阶：搞定“地图选点”与“瀑布流”

> 🌤️ **心情/状态**：今天挑战了两个看起来很复杂的交互功能，一开始心里没底，但拆解开来发现逻辑其实很清晰。看着地图上的图钉稳稳扎在中心，还有照片像瀑布一样流淌，成就感爆棚！

## 💡 今日份“顿悟”
1.  **地图选点的逆向思维**：
    以前以为选点是“点击地图哪里，图标就飞过去”。今天才明白，主流体验其实是**“图钉不动，地图动”**。屏幕中心的图钉就像显微镜的镜头，我们移动的是载玻片（地图）。
2.  **瀑布流的本质是“发牌”**：
    以前以为瀑布流是复杂的 CSS 魔法。其实用 JS 数组把图片像“发扑克牌”一样分给几列，再配合 `widthFix` 让高度自适应，效果自然就出来了。

## 🧠 知识内化（复现指南）

### 🗺️ 技能一：拖动地图选址（Map Dragging）
这是一个“配置+布局+逻辑”的组合拳。

**1. 权限配置（门票）**
在 `app.json` 中必须声明，否则 `wx.getLocation` 直接报错。
```json
"permission": { "scope.userLocation": { "desc": "用于定位" } },
"requiredPrivateInfos": ["getLocation"]
```

**2. 布局技巧（定海神针）**
核心是**层叠布局**。
*   **容器**：`position: relative`。
*   **地图**：铺满容器。
*   **图钉**：`position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);`。
*   **动画**：监听拖动状态，拖动时 `translate Y` 向上位移更多（抬起），停止时复位（扎下）。

**3. 核心逻辑（取值）**
不要在拖动过程中疯狂更新，只在**停下**那一刻取值。
*   **监听**：`bindregionchange` 事件。
*   **判断**：`e.type === 'end'` 且 `e.causedBy === 'drag'`。
*   **获取**：调用 `mapCtx.getCenterLocation()` 拿到当前地图中心的经纬度。

### 🌊 技能二：相册瀑布流（Waterfall Layout）
我们采用了**JS分列 + Flex布局**的方案，比纯 CSS 更可控。

**1. 核心原理（发牌算法）**
准备 3 个数组（左、中、右），遍历图片列表，按顺序轮询分配。
```javascript
// 伪代码：Round-Robin 分配
images.forEach((img, index) => {
  if (index % 3 === 0) leftList.push(img);
  else if (index % 3 === 1) centerList.push(img);
  else rightList.push(img);
});
```

**2. 关键属性（自适应高度）**
在 WXML 中，图片组件必须设置 `mode="widthFix"`。
这样我们只需要用 CSS 固定每列的宽度（例如 32%），图片高度就会根据原图比例自动撑开，形成错落有致的效果。

## 🚀 接下来我要做什么（Action Items）
- [ ] **[真机验证]**：在手机上测试地图选点，特别是检查 iOS 和 Android 的定位权限弹窗是否正常。
- [ ] **[算法优化]**：目前的瀑布流是轮询分配，如果长图都挤在一列会很难看。下一步尝试“高度优先”算法：每次把新图塞给当前高度最小的那一列。
- [ ] **[防抖处理]**：地图拖动结束后的接口请求可能需要加个防抖，防止用户手抖频繁触发请求。

## 💭 碎碎念
今天的开发让我意识到，很多看似高大上的交互，背后都是朴素的算法。地图选点是“相对运动”，瀑布流是“数组拆分”。把复杂问题拆解成基础模型，这可能就是编程的乐趣吧。
