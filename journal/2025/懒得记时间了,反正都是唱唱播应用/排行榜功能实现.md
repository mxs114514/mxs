# 排行榜功能实现总结

本文档总结了“音乐笑传之唱唱播”项目中排行榜功能的实现全过程，涵盖数据库设计、后端接口开发、前端逻辑埋点及界面实现。

## 1. 功能需求

实现 6 个维度的音乐排行榜：
1.  **播放榜**：月榜、年榜、总榜
2.  **收藏榜**：月榜、年榜、总榜

**交互要求**：
*   首页展示所有榜单卡片，卡片内预览前 3 名。
*   点击卡片进入详情页。
*   详情页 Top 3 以大卡片展示（带醒目标识），后续排名以列表展示。

## 2. 数据库设计 (Prisma Schema)

利用现有的模型支持统计功能，无需新增表结构，只需利用好关联关系。

*   **总榜**：直接在 `Song` 表中维护计数器字段，利用索引快速排序。
*   **时段榜（月/年）**：通过关联记录表（`PlayRecord`, `Favorite`）按时间范围聚合统计。

```prisma
// server/prisma/schema.prisma

model Song {
  id        Int      @id @default(autoincrement())
  // ...
  playCount Int      @default(0) // 用于“播放总榜”快速排序
  
  playRecords PlayRecord[] // 关联播放记录
  favoritedBy Favorite[]   // 关联收藏记录

  @@index([playCount]) // 索引优化
}

model PlayRecord {
  id       Int      @id @default(autoincrement())
  playedAt DateTime @default(now()) // 关键：用于按时间筛选（月榜/年榜）
  songId   Int
  userId   Int?     // 允许匿名播放记录
  
  song     Song     @relation(fields: [songId], references: [id])
  @@index([playedAt])
}

model Favorite {
  // ...
  createdAt DateTime @default(now()) // 关键：用于按时间筛选
  // ...
}
```

## 3. 后端实现 (Express + Prisma)

### 3.1 记录播放次数 (埋点接口)

为了统计播放榜，每次播放时需要调用此接口。它执行两个操作：
1.  插入一条 `PlayRecord`（用于时段统计）。
2.  原子增加 `Song.playCount`（用于总榜快速读取）。

```typescript
// server/src/controllers/song.controller.ts

export const recordPlay = async (req: Request, res: Response) => {
  const songId = Number(req.params.id)
  
  // 1. 创建播放记录
  await prisma.playRecord.create({
    data: { songId, userId: req.user?.id }
  })

  // 2. 增加总计数
  await prisma.song.update({
    where: { id: songId },
    data: { playCount: { increment: 1 } }
  })
  
  res.json({ success: true })
}
```

### 3.2 获取播放排行榜

根据 `type` 参数决定查询策略：
*   `total`: 直接查 `Song` 表，性能最高。
*   `month`/`year`: 查 `PlayRecord` 表并聚合 (`groupBy`)。

```typescript
// server/src/controllers/song.controller.ts

export const getPlayRank = async (req: Request, res: Response) => {
  const { type } = req.query // 'month' | 'year' | 'total'

  // 策略 A: 总榜 (直接查 Song)
  if (type === 'total') {
    const songs = await prisma.song.findMany({
      orderBy: { playCount: 'desc' },
      take: 50,
      include: { uploader: true }
    })
    return res.json(songs)
  }

  // 策略 B: 时段榜 (聚合 PlayRecord)
  // 1. 计算时间范围
  const now = new Date()
  // ... 计算 startDate, endDate ...

  // 2. 聚合查询
  const groupResult = await prisma.playRecord.groupBy({
    by: ['songId'],
    where: { playedAt: { gte: startDate, lt: endDate } },
    _count: { songId: true },
    orderBy: { _count: { songId: 'desc' } },
    take: 50
  })

  // 3. 填充歌曲详情 (略)
  // ...
}
```

## 4. 前端逻辑实现

### 4.1 播放埋点 (Store 模式)

**最佳实践**：不要在 UI 组件（如播放栏）中调用埋点接口，而是在状态管理（Pinia Store）的播放动作中统一处理。这样无论从哪里触发播放（列表点击、自动切歌、随机播放），都能被记录。

```typescript
// src/stores/player.ts

const playSong = (song: SongType) => {
  // 1. 更新状态
  currentSong.value = song
  isPlaying.value = true

  // 2. 异步记录播放 (不阻塞 UI)
  recordPlayApi(song.id).catch(console.error)
}
```

## 5. 前端界面实现 (Vue 3 + Element Plus)

### 5.1 排行榜主页 (`RankView.vue`)

采用 **配置化驱动** 的方式渲染 6 个榜单卡片，避免重复代码。

```typescript
// 榜单配置定义
const rankDefs = [
  { 
    id: 'play_month', 
    title: '播放月榜', 
    api: getPlayRank, 
    arg: 'month', 
    bgColor: 'linear-gradient(...)', // 不同榜单不同颜色
    icon: Calendar 
  },
  // ... 其他 5 个榜单
]
```

**核心布局**：
*   **概览模式**：Grid 布局展示卡片，每个卡片内循环展示前 3 名数据。
*   **详情模式**：点击卡片后，通过 `v-if/else` 切换视图。

### 5.2 榜单详情页

详情页分为两部分：
1.  **Top 3 区域**：复用 `SongList` 组件，以大图卡片形式展示。
2.  **列表区域**：使用 `el-table` 展示第 4-30 名，包含详细数据列。

### 5.3 醒目的排名角标

为了区分前三名，修改了通用的 `SongList` 组件。

**实现方式**：
1.  新增 props: `showRank: boolean`。
2.  在卡片左上角添加绝对定位的 Badge。
3.  根据 `index` 动态应用样式类 (`rank-1`, `rank-2`, `rank-3`)。

```vue
<!-- src/components/business/SongList.vue -->
<div v-if="showRank" class="rank-badge" :class="'rank-' + (index + 1)">
  <template v-if="index === 0">NO.1 🏆</template>
  <template v-else-if="index === 1">NO.2 🥈</template>
  <!-- ... -->
</div>

<style scoped>
.rank-1 { background: linear-gradient(to right, #f56c6c, #f29b9b); }
/* ... */
</style>
```

## 6. 总结与经验

1.  **后端聚合查询**：Prisma 的 `groupBy` 是实现统计榜单的神器，配合 `_count` 可以轻松完成复杂的统计需求。
2.  **业务逻辑解耦**：将“记录播放”逻辑放在 Store 而不是组件中，保证了逻辑的完整性和可维护性。
3.  **组件复用与增强**：通过给 `SongList` 增加开关属性 (`showRank`)，既保持了组件的通用性，又满足了特定场景（排行榜）的定制需求，避免了复制粘贴代码。
4.  **配置化 UI**：对于结构相似但数据源不同的界面（6个榜单），使用配置数组 (`rankDefs`) 配合 `v-for` 渲染，比写 6 遍 HTML 要优雅得多。
