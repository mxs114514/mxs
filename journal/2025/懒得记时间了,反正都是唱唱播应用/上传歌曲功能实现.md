# 上传歌曲功能实现 (后端篇)

## 1. 设计思路

### 1.1 业务模式选择
我们采用了 **“全员可见 (UGC)”** 模式。
- 用户上传的歌曲会自动进入公共曲库，所有用户都能在列表中看到并播放。
- 歌曲会标记“上传者”，前端可展示“由 xxx 上传”。
- 用户只能删除自己上传的歌曲（前端控制入口，后端需配合校验）。

### 1.2 数据库策略
**策略：复用 `Song` 表**
我们没有新建 `UserUploadSong` 表，而是直接在现有的 `Song` 表中扩展字段。
- **优点**：
    - **统一播放逻辑**：前端播放器不需要区分是“系统歌”还是“用户歌”。
    - **统一搜索**：搜索功能天然支持搜索用户上传的歌曲。
    - **关联简单**：收藏、播放记录等关联表不需要修改。

---

## 2. 数据库实现 (Prisma)

### 2.1 Schema 变更
在 `server/prisma/schema.prisma` 中，我们对 `Song` 和 `User` 模型进行了关联。

```prisma
model Song {
  // ... 原有字段 ...
  
  // 新增：上传者关联
  // uploaderId 为 null 表示系统官方歌曲
  // uploaderId 有值 表示用户上传的歌曲
  uploaderId Int?
  uploader   User? @relation("UserUploads", fields: [uploaderId], references: [id])

  @@index([uploaderId]) // 添加索引优化查询
}

model User {
  // ... 原有字段 ...

  // 新增：反向关联，方便查询“我上传的歌”
  uploadedSongs Song[] @relation("UserUploads")
}
```

### 2.2 数据迁移
修改完成后，执行了以下命令更新数据库结构：
```bash
npx prisma migrate dev --name add_uploader_to_song
```

---

## 3. 核心代码实现

### 3.1 文件上传中间件 (Multer)
文件：`server/src/middleware/upload.middleware.ts`

我们需要处理两种文件：**音频文件**和**封面图片**。
- 音频存入 `public/songs`
- 封面存入 `public/covers`

**关键技术点**：
1.  **智能分流**：在 `destination` 回调中，根据 `file.fieldname` 判断存入哪个文件夹。
2.  **自动创建目录**：使用 `fs.existsSync` + `fs.mkdirSync` 确保文件夹存在。
3.  **文件重命名**：使用 `时间戳 + 随机数` 防止文件名冲突，并处理中文文件名乱码问题。

```typescript
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    if (file.fieldname === 'cover') {
      cb(null, coversDir)
    } else {
      cb(null, songsDir)
    }
  },
  // ... filename 逻辑 ...
})
```

### 3.2 控制器逻辑 (Controller)
文件：`server/src/controllers/song.controller.ts`

#### A. 获取歌曲列表 (`getSongs`)
修改了查询逻辑，使其返回所有歌曲，并带上上传者信息。

```typescript
const songs = await prisma.song.findMany({
  where: { isDeleted: false }, // 不再限制 uploaderId
  include: {
    uploader: { select: { nickname: true, username: true } } // 关联查询上传者
  }
})
```

#### B. 上传歌曲 (`uploadSong`)
这是核心业务逻辑，包含以下步骤：
1.  **接收文件**：从 `req.files` 中提取 `file` (音频) 和 `cover` (图片)。
2.  **解析元数据**：使用 `music-metadata` 库解析音频文件的时长 (`duration`)。
3.  **默认值兜底**：
    - 歌名：优先取 `req.body.title` -> 其次取文件名。
    - 歌手：优先取 `req.body.artist` -> 其次默认为 "未知歌手"。
    - 专辑：优先取 `req.body.album` -> 其次默认为 "未知专辑"。
4.  **入库**：创建 `Song` 记录，关联当前登录用户 ID。
5.  **错误处理**：如果入库失败，**自动删除**已上传的垃圾文件。

```typescript
// 路由配置 (server/src/routes/song.routes.ts)
router.post(
  '/upload',
  authMiddleware, // 1. 验证登录
  uploadMiddleware.fields([ // 2. 处理文件
    { name: 'file', maxCount: 1 },
    { name: 'cover', maxCount: 1 },
  ]),
  uploadSong // 3. 业务逻辑
)
```

---

## 4. API 接口规范

### 上传歌曲接口
- **URL**: `/api/songs/upload`
- **Method**: `POST`
- **Content-Type**: `multipart/form-data`
- **权限**: 需要登录 (Header: `Authorization: Bearer <token>`)

**请求参数 (FormData)**:

| 字段名 | 类型 | 必填 | 说明 |
| :--- | :--- | :--- | :--- |
| `file` | File | **是** | 音频文件 (mp3, flac 等) |
| `cover` | File | 否 | 封面图片 (jpg, png)。不传则使用默认封面。 |
| `title` | String | 否 | 歌名。不传自动使用文件名。 |
| `artist` | String | 否 | 歌手。不传默认为 "未知歌手"。 |
| `album` | String | 否 | 专辑。不传默认为 "未知专辑"。 |

**响应示例**:
```json
{
  "id": 101,
  "title": "稻香",
  "artist": "周杰伦",
  "url": "/songs/1734321123-稻香.mp3",
  "cover": "/covers/1734321123-cover.jpg",
  "uploaderId": 5,
  "createdAt": "..."
}
```

### 常见问题 (FAQ)

#### Q1: Token 具体是什么？
Token 是用户登录接口 (`/login`) 成功响应后返回的 **JSON Web Token (JWT)** 字符串。
前端在调用上传接口时，必须在请求头中携带它：
- **Header Key**: `Authorization`
- **Header Value**: `Bearer <你的Token字符串>` (注意中间有空格)

#### Q2: 后端是如何获取当前用户 ID 的？
后端通过解析请求头中的 JWT 来获取用户 ID。
1.  `authMiddleware` 拦截请求，提取 `Authorization` 头中的 Token。
2.  使用 `jwt.verify` 解密 Token，还原出 payload 数据（包含 `userId`）。
3.  将 `userId` 赋值给 `req.user.id`。
4.  后续的 Controller (如 `uploadSong`) 直接读取 `req.user.id` 即可知道是谁在操作。

---

## 5. 后续扩展建议
1.  **文件大小限制**：目前限制为 50MB，如果支持无损音乐可能需要调大。
2.  **封面提取**：目前如果用户不传封面，就用默认图。进阶做法是可以尝试从 MP3 文件的 ID3 Tag 中提取内嵌封面。
3.  **审核机制**：当前是上传即公开。如果用户量大，建议增加 `status` 字段 (PENDING, APPROVED)，后台审核通过后才在列表显示。

---

# 上传歌曲功能实现 (前端篇)

## 1. 设计思路

### 1.1 交互设计
- **用户体验优先**: 采用拖拽上传和点击上传两种方式，支持音频和封面预览。
- **智能辅助**: 自动从文件名解析歌名和歌手（例如 "周杰伦 - 稻香.mp3"），减少用户输入工作量。
- **流程优化**:
    - **单文件限制**: 每次只能上传一首，但支持“选择即替换”的流畅操作，无需手动删除旧文件。
    - **连续上传**: 上传成功后不跳转页面，而是清空表单，方便用户连续上传多首歌曲。

### 1.2 技术选型
- **框架**: Vue 3 (Composition API) + TypeScript
- **UI 组件库**: Element Plus (`el-upload`, `el-form`)
- **网络请求**: Axios (封装在 `src/utils/request.ts`)

---

## 2. 核心代码实现

### 2.1 API 封装 (`src/api/songs.ts`)
前端使用 `FormData` 对象来构建请求体，这是处理文件上传的标准方式。

```typescript
export const uploadSong = (data: UploadSong) => {
  const formData = new FormData()
  formData.append('file', data.file)
  if (data.cover) formData.append('cover', data.cover)
  // ... append 其他文本字段 ...

  // 注意：不要手动设置 Content-Type，axios 会自动识别 FormData 并设置正确的 boundary
  return request.post('/songs/upload', formData)
}
```

### 2.2 视图实现 (`src/views/UpLoadSongView.vue`)

#### A. 状态管理
使用 `reactive` 管理表单数据，使用 `ref` 管理文件对象和上传组件实例。

```typescript
const form = reactive({ title: '', artist: '', album: '' })
const songFile = ref<File | null>(null)
const songUploadRef = ref<UploadInstance>() // 用于清空文件列表
```

#### B. 智能文件处理 (`handleSongChange`)
我们实现了两个关键逻辑：
1.  **自动替换**: 虽然设置了 `:limit="1"`，但为了优化体验，我们在 `on-change` 钩子中手动处理 `fileList`。如果用户选择了新文件，代码会自动移除旧文件，实现无缝替换。
2.  **元数据填充**: 利用正则去后缀，并尝试按 " - " 分割字符串，自动填充歌名和歌手。

```typescript
const handleSongChange = (file: UploadFile, fileList: UploadFile[]) => {
  // 1. 限制单文件：新文件顶掉旧文件
  if (fileList.length > 1) fileList.splice(0, 1)

  if (file.raw) {
    songFile.value = file.raw
    // 2. 自动填充逻辑
    const name = file.name.replace(/\.[^/.]+$/, '')
    if (name.includes('-')) {
      const parts = name.split('-')
      if (!form.artist) form.artist = parts[0].trim()
      if (!form.title) form.title = parts.slice(1).join('-').trim()
    } else {
      if (!form.title) form.title = name
    }
  }
}
```

#### C. 提交与重置 (`submitUpload`)
上传成功后的处理逻辑：
1.  提示成功消息。
2.  **清空所有状态**：包括表单文本、文件对象引用。
3.  **清除 UI 状态**：调用 Element Plus Upload 组件的 `clearFiles()` 方法，移除界面上的文件列表。

```typescript
// 成功后的清理工作
form.title = ''
form.artist = ''
form.album = ''
songFile.value = null
coverFile.value = null
songUploadRef.value?.clearFiles()  // 清除歌曲上传组件的文件列表
coverUploadRef.value?.clearFiles() // 清除封面上传组件的文件列表
```

---

## 3. 遇到的问题与解决方案

### 3.1 问题：布局重复嵌套 (Double Layout)
- **现象**: 页面出现了两个侧边栏和顶部栏，布局错乱。
- **原因**: `App.vue` 中已经全局使用了 `BasicLayout` 包裹 `<RouterView>`，而在 `UpLoadSongView.vue` 内部又错误地引入并使用了一次 `BasicLayout`。
- **解决**: 删除视图组件中的布局容器，只保留内容区域。Vue Router 会自动将内容渲染到 App.vue 的插槽中。

### 3.2 问题：文件选择限制体验不佳
- **现象**: 设置 `:limit="1"` 后，Element Plus 默认行为是阻止选择第二个文件。用户想换一个文件时，必须先点击删除按钮删掉旧的，才能选新的，操作繁琐。
- **解决**: 在 `on-change` 事件中手动干预 `fileList`。
  ```typescript
  if (fileList.length > 1) {
    fileList.splice(0, 1) // 移除索引0（旧文件），保留索引1（新文件）
  }
  ```
  这样实现了“选择即替换”的流畅体验。

### 3.3 问题：上传成功后的交互流
- **现象**: 最初设计是上传成功后跳转到“我的音乐”列表。
- **反馈**: 用户反馈如果想连续上传多首歌曲，跳转会打断流程，体验不好。
- **解决**: 改为上传成功后 `ElMessage.success` 提示，并原地清空表单，让用户可以立即进行下一次上传。

### 3.4 问题：Axios 请求头设置 (Boundary 丢失)
- **现象**: 手动设置 `Content-Type: multipart/form-data` 导致后端报错 `Boundary not found`。
- **原因**: `multipart/form-data` 需要一个 boundary 字符串来分隔不同字段，手动设置 Header 会覆盖浏览器自动生成的带 boundary 的 Header。
- **解决**: 移除手动设置的 Header，直接传递 `FormData` 对象，让 Axios 和浏览器自动处理。

