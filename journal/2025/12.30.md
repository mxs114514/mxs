# 2025.12.30 — 实习第一天总结

今天是实习的第一天。

公司的技术栈是 Vue 与 uni-app。因为刚上班还未分配正式任务，我在工位上花了一整天阅读 uni-app 的文档，了解跨端相关的概念（如 nvue、nts、webview、weex），以及逻辑层与渲染层的分离，并下载安装并学习了 HBuilderX 的使用。阅读文档的过程中，我也陷入了一些迷茫，下面是我与 AI 的对话要点与整理的笔记。

## 文档 vs 实际项目

- 看文档的感觉
  - 信息量大且无上下文：容易“知道但不会用”。
  - 文档更像字典，不是小说，通读意义不大。

- 做项目的体验（边做边学）
  - 有明确目标，遇到问题再查文档，理解更深刻；
  - 实战中学习更牢固，能积累经验。

## 我与 AI 的对话（节选）

AI 给了我一些心态与方法上的建议：

- 磕磕碰碰是正常且有价值的学习过程：每个 bug 都是学习机会；
- 不需要把文档读完再开始，先掌握核心 20% 概念，其他“用到再查”；
- 问题驱动学习最有效：当你需要做某个功能时，查相应的 API/用法，解决问题并记住。

示例（从大问题拆小问题）：做“情侣相册”功能可以分解为

- 显示一张图片
- 显示多张图片
- 点击放大图片
- 上传新图片

并且要允许自己犯错、庆祝小进步（例如：成功运行项目、修改文字、加点击效果、解决一个 bug 等）。

## 应对“磕磕碰碰”的实操策略

1. 预期会出错：主动接受第 1、3、5 次出错是正常现象；
2. 善用搜索：把错误信息和关键字直接搜（如：`uni-app [你的问题]`）；
3. 分解问题：把复杂需求拆成一系列小目标逐步实现。

## uni-app 最核心的 20% 概念

这些概念是我应优先掌握的：

1. 项目结构：目录与文件的职责；
2. 页面与组件：如何创建与显示；
3. 数据绑定：实现数据与界面联动；
4. 事件处理：响应用户操作；
5. 路由与跳转：页面切换机制；
6. 生命周期：页面/组件的生命周期钩子；
7. 条件编译：一套代码适配多平台（条件编译指令）。

## 分配的任务 & 难点

公司给我分配了一个类似网课播放的小程序页面，两个主要难点：

1. 视频播放性能：一节网课可能从半小时到几小时，不能简单地把整段 MP4 下载完再播放；需要考虑分段加载、流式播放或利用平台提供的播放能力来降低卡顿；
2. 长列表的性能：课程列表、任务列表可能非常长，需要做渲染层和数据层的优化。

于是我展开了技术调研，记录如下：

### 视频方面：性能优化方案

针对网课视频时长大（半小时至数小时）的特点，不能采用全量下载。经过调研，制定了分阶段的优化方案。

#### 1. 核心技术原理

- **HTTP Range Requests (范围请求)**：这是“边下边播”和“拖拽进度”的基石。播放器通过 `Range: bytes=start-end` 请求头，只请求视频的特定片段，而非下载整个文件。
- **H.264 编码**：兼容性最好的视频编码格式，确保在各种设备上利用硬件解码，省电且流畅。

#### 2. 实施路线图

**第一阶段：短期快速优化（前端主导）**

*   **启用 Range 请求**：
    *   确认 OSS 或后端接口支持 `Range` 请求头（返回 206 状态码）。主流 OSS（阿里云、腾讯云）默认支持。
    *   前端 `<video>` 组件直接使用链接，会自动发送 Range 请求。
*   **智能预加载**：
    *   **列表页**：静默预加载下一节课的元数据（时长、大小）或首个分片（前 1-2MB），利用 `uni.downloadFile` 或 XHR。
    *   **详情页**：`onLoad` 时立即请求视频地址并初始化播放器，设置 `preload="auto"`。
*   **体验优化**：
    *   利用 `initial-time` 实现断点续播。
    *   监控下载速率，若持续低于码率则提示用户切换清晰度（如果有多清晰度源）。

**第二阶段：长期架构升级（服务端主导）**

*   **HLS 流媒体**：
    *   将原始 MP4 转码为 **HLS (.m3u8 + .ts)** 格式。
    *   **切片**：将大文件切成小的 `.ts` 文件，秒开速度更快。
    *   **多码率适配**：生成不同清晰度（1080p, 720p, 480p）的流，播放器根据网络状况提醒用户切换,如果开了自动则自动切换（Adaptive Bitrate Streaming）。
*   **CDN 加速**：配合 CDN 分发切片文件，降低延迟。

#### 3. 决策建议

1.  **立即行动**：检查现有视频文件是否为 **H.264 编码的 MP4**。
    *   如果是：直接上 Range 请求 + 预加载方案。
    *   如果不是：优先转码为 H.264。
2.  **后续规划**：随着用户量增长，搭建服务端转码服务，向 HLS 方案迁移。
### 列表方面：虚拟列表 vs 懒加载

1) 懒加载（Lazy Loading）

- 本质：数据层按需加载（例如先加载前 20 条，滚动到底再加载下 20 条）；
- 问题：虽然减少了初始请求，但最终仍可能渲染大量 DOM 元素，导致页面卡顿。

2) 虚拟列表（Virtual List）

- 本质：渲染层优化的进阶方案，只渲染可视区域内的少量 DOM 元素；
- 核心：通过占位容器模拟总高度，滚动时回收离开可视区域的 DOM，用它们渲染新进入可视区域的数据；
- 关键技术点：
  - 计算每个项目高度（固定或动态）；
  - 根据滚动位置计算显示范围（startIndex、endIndex）；
  - 使用偏移（例如 transform: translateY(...)）来模拟正确位置。