登录功能实现
1.在数据库里，我们绝对不能存储用户的明文密码（比如 "123456"）。因为一旦数据库泄露，所有人的密码就都公开了。
所以我们需要一个“加密”过程（通常叫 Hash，哈希）。

注册时：用户输入 "123456" -> 我们变成 "d7a8f..." 存进数据库。
登录时：用户输入 "123456" -> 我们用同样的算法算出 "d7a8f..." -> 跟数据库里的比对 -> 一样就是密码正确。
比对成功后，服务器发给前端一个“令牌 (Token)”。前端拿着这个令牌，就像拿着一张门禁卡，以后访问需要登录的接口（比如“修改个人资料”），出示令牌即可。

需要安装:安装 bcryptjs (用于密码加密) 和 jsonwebtoken (用于生成 Token)。


登录页面动画实现:
一、 当前动画的实现原理拆解
这个动画看起来很复杂，其实可以拆解为三个图层和一种状态切换机制。

1. 核心机制：状态开关
Vue 中只做了一件事：
<!-- 动态绑定 class -->
<div class="container" :class="{ 'sign-up-mode': isSignUpMode }">
默认状态：没有 sign-up-mode 类。
注册状态：有 sign-up-mode 类。
CSS 中所有的动画逻辑都是基于 .container.sign-up-mode ... 选择器来写的。
2. 图层拆解 (由下到上)
第一层：表单层 (.signin-signup)

布局：它包含两个 <form>，通过 grid 布局重叠在一起（或者绝对定位重叠）。
默认：它在右边 (left: 75%)。
变化：当变成注册模式时，它跑到左边 (left: 25%)。
显隐：
登录表单默认 z-index: 2 (在上)，注册表单 z-index: 1 (在下，且 opacity: 0)。
切换时，注册表单变 opacity: 1，登录表单变 opacity: 0。
第二层：蓝色背景层 (.container:before)

原理：这是一个巨大的圆形（width: 2000px），通过 position: absolute 定位在容器上方。
默认：它在右上方。
变化：添加 .sign-up-mode 后，通过 transform: translate(...) 把它平移到左下方。
作用：它充当了“幕布”，在移动过程中遮挡住表单的切换细节。
第三层：文字图片层 (.panels-container)

布局：左右两个 .panel。
默认：
左面板（新朋友？）：在正常位置。
右面板（已会员？）：在屏幕右侧外面 (translateX(800px))，你看不到它。
变化：
左面板：移出屏幕左侧 (translateX(-800px))。
右面板：移入屏幕中间 (translateX(0))。
3. 灵魂所在：transition-delay (延迟)
你注意到动画很“顺滑”吗？是因为文字和图片不是马上移动的。
.panel .content {
  transition: transform 0.9s ease-in-out;
  transition-delay: 0.6s; /* 重点！ */
}
逻辑：先让蓝色背景球开始移动（挡住视线），过了 0.6秒，文字和图片再开始移动。这就制造了一种“背景把内容带出来”的视觉错觉。
二、 以后自己写类似动画的思路 (五步法)
如果你以后想写“点击一个按钮，界面发生巨大变化”的动画，请遵循以下步骤：

第一步：布局 (Layout is King)
不要去想动画，先想静止状态。

把所有元素（登录表单、注册表单、左边图、右边图）都放在 HTML 里。
利用 position: absolute 把它们叠放在一起，或者放在屏幕外。
关键点：父容器必须 overflow: hidden，这样飞出屏幕的元素才不会导致出现滚动条。
第二步：定义“状态 A” (CSS Default)
写 CSS，让页面呈现默认的样子（比如登录态）。

把不需要显示的元素（如注册表单、右侧图片）用 opacity: 0 隐藏，或者用 transform: translateX(100%) 扔到屏幕外面去。
第三步：定义“状态 B” (CSS Modifier)
在 CSS 里写一个修饰类，比如 .active 或 .mode-b。
在这个类下，重写元素的位置。
/* 伪代码示例 */
.box { left: 0; }       /* 状态 A */

.container.active .box { /* 状态 B */
  left: 100%; 
}
第四步：添加过渡 (Transition)
给变化的属性加上 transition。
.element {
  /* 推荐 */
  transition: transform 0.5s ease;
  
  /* 尽量避免 */
  /* transition: left 0.5s ease; */
}
黄金法则：尽量只改变 transform (位置/缩放) 和 opacity (透明度)。
原因：改变 left/top/width/height 会触发浏览器“重排” (Reflow)，很卡；而改变 transform 只需要“重绘” (Repaint)，由 GPU 加速，非常丝滑。
第五步：微调 (Polish)
这是区分新手和高手的关键。

交错动画 (Staggering)：不要让所有东西同时动。给图片加 delay: 0.2s，给文字加 delay: 0.3s。
贝塞尔曲线 (Easing)：不要只用 linear。使用 ease-in-out 或者自定义 cubic-bezier 让运动有快慢节奏。

这是一份为你准备的博客文章大纲和内容草稿，涵盖了从需求分析、代码实现到踩坑解决的全过程。你可以根据自己的博客风格进行润色。

Vue3 + Pinia 实战：如何实现播放器音量与倍速的持久化存储
在开发音乐播放器时，用户体验至关重要。如果用户调整了音量或播放倍速，刷新页面或切换歌曲后这些设置就重置了，体验会非常糟糕。本文将记录我在 Vue 3 + Pinia 项目中实现这一功能的完整过程，以及遇到的一个关于 Vue 组件复用的“坑”。

一、 需求分析
我们需要实现两个核心目标：

持久化：用户调整音量或倍速后，数据要保存到 localStorage，刷新页面后自动恢复。
同步：Pinia Store 中的状态要与原生 <audio> 元素的属性实时双向绑定。
二、 实现步骤
1. Pinia 状态管理改造 (stores/player.ts)
首先，我们需要在 Store 中增加状态，并修改保存和恢复的逻辑。

核心改动：

增加 currenVolume 和 currenRate 状态。
在 saveState 中将这两个值写入本地存储。
在 restoreState 中读取并恢复它们。
使用 watch 监听这两个值的变化，一旦改变立即触发保存。
// stores/player.ts
export const usePlayerStore = defineStore('player', () => {
  // 1. 定义状态
  const currenRate = ref(1.0)
  const currenVolume = ref(1.0)

  // 2. 保存状态到 localStorage
  const saveState = () => {
    const state = {
      // ...其他状态
      volume: currenVolume.value,
      rate: currenRate.value,
    }
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state))
  }

  // 3. 恢复状态
  const restoreState = () => {
    const saved = localStorage.getItem(STORAGE_KEY)
    if (saved) {
      const parsed = JSON.parse(saved)
      if (parsed.volume !== undefined) currenVolume.value = parsed.volume
      if (parsed.rate !== undefined) currenRate.value = parsed.rate
    }
  }

  // 4. 监听变化自动保存
  watch([currenVolume, currenRate], () => {
    saveState()
  })

  return { currenRate, currenVolume, ... }
})
2. 组件层双向绑定 (AppFooterPlayerBar.vue)
在组件中，我们需要连接 Store 和 <audio> 标签。这里涉及三个关键的事件节点：

初始化恢复 (Store -> Audio)：当音频元数据加载完成时 (loadedmetadata)，将 Store 中的值赋给 <audio>。
用户操作 (Audio -> Store)：当用户拖动进度条或修改倍速时 (volumechange, ratechange)，更新 Store。
响应式同步 (Store -> Audio)：如果通过代码修改了 Store，需要同步回 <audio>。
// AppFooterPlayerBar.vue
const { currenVolume, currenRate } = storeToRefs(playerStore)

// 1. 恢复上次的设置
const onLoadedMetadata = () => {
  if (audioRef.value) {
    audioRef.value.volume = currenVolume.value
    audioRef.value.playbackRate = currenRate.value
  }
}

// 2. 监听原生事件，同步到 Store
const onVolumeChange = () => {
  if (audioRef.value) playerStore.currenVolume = audioRef.value.volume
}
const onRateChange = () => {
  if (audioRef.value) playerStore.currenRate = audioRef.value.playbackRate
}

// 3. 监听 Store 变化，同步回 Audio (防止死循环加了判断)
watch(currenVolume, (newVal) => {
  if (audioRef.value && Math.abs(audioRef.value.volume - newVal) > 0.01) {
    audioRef.value.volume = newVal
  }
})

这是一份为你准备的博客文章大纲和内容草稿，涵盖了从需求分析、代码实现到踩坑解决的全过程。你可以根据自己的博客风格进行润色。

Vue3 + Pinia 实战：如何实现播放器音量与倍速的持久化存储
在开发音乐播放器时，用户体验至关重要。如果用户调整了音量或播放倍速，刷新页面或切换歌曲后这些设置就重置了，体验会非常糟糕。本文将记录我在 Vue 3 + Pinia 项目中实现这一功能的完整过程，以及遇到的一个关于 Vue 组件复用的“坑”。

一、 需求分析
我们需要实现两个核心目标：

持久化：用户调整音量或倍速后，数据要保存到 localStorage，刷新页面后自动恢复。
同步：Pinia Store 中的状态要与原生 <audio> 元素的属性实时双向绑定。
二、 实现步骤
1. Pinia 状态管理改造 (stores/player.ts)
首先，我们需要在 Store 中增加状态，并修改保存和恢复的逻辑。

核心改动：

增加 currenVolume 和 currenRate 状态。
在 saveState 中将这两个值写入本地存储。
在 restoreState 中读取并恢复它们。
使用 watch 监听这两个值的变化，一旦改变立即触发保存。
2. 组件层双向绑定 (AppFooterPlayerBar.vue)
在组件中，我们需要连接 Store 和 <audio> 标签。这里涉及三个关键的事件节点：

初始化恢复 (Store -> Audio)：当音频元数据加载完成时 (loadedmetadata)，将 Store 中的值赋给 <audio>。
用户操作 (Audio -> Store)：当用户拖动进度条或修改倍速时 (volumechange, ratechange)，更新 Store。
响应式同步 (Store -> Audio)：如果通过代码修改了 Store，需要同步回 <audio>。
三、 遇到的坑：切歌导致音量重置
功能上线后，我发现了一个奇怪的 Bug：虽然刷新页面音量能保持，但只要一切换歌曲，音量就会瞬间变回 100%（最大声）。

问题排查
经过调试发现，问题出在 <audio> 标签的 :key 属性上：
<!-- ❌ 有问题的写法 -->
<audio :key="currentSong.id" :src="currentSong.url" ... />
原因分析：

我为了让切歌时组件强制重新渲染（通常为了重置播放状态），给 <audio> 绑定了 :key="song.id"。
Vue 的机制：当 key 变化时，Vue 会销毁旧的 DOM 元素，并创建一个新的 DOM 元素。
浏览器的机制：新创建的 <audio> 元素，默认音量 (volume) 是 1.0。
连锁反应：
切歌 -> key 变了 -> 旧 <audio> 销毁 -> 新 <audio> 创建。
新 <audio> 音量默认为 1.0 -> 触发 volumechange 事件。
onVolumeChange 执行 -> 将 Store 中的 currenVolume 更新为 1.0。
结果：用户之前保存的音量设置被覆盖了。
解决方案
核心思路：不要销毁 <audio> 元素，而是复用它，只修改 src。

移除 :key：
让 Vue 复用同一个 DOM 节点，这样 <audio> 元素原本的 volume 和 playbackRate 属性就会保持不变。

<!-- ✅ 修正后的写法 -->
<audio ref="audioRef" :src="currentSong.url" ... />
手动重置进度：
因为元素被复用了，切歌时播放进度不会自动归零。我们需要在 Store 的切歌逻辑中手动重置：
// stores/player.ts
const playSong = (song: SongType) => {
  currentSong.value = song
  currentTime.value = 0 // 手动归零
  isPlaying.value = true
}
四、 总结
实现播放器状态同步看似简单，实则涉及了 Vue 的生命周期、DOM 复用机制以及原生 Audio API 的特性。

持久化：利用 Pinia 的 watch 和 localStorage。
双向绑定：利用 loadedmetadata 做初始化，volumechange 做更新。
避坑指南：在处理 <audio> 或
<video> 这类有内部状态的标签时，谨慎使用 :key，尽量采用复用策略，避免因 DOM 重建导致的状态丢失。