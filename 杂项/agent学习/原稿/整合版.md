# Agent 方向学习规划（前端向）

最后更新：2026-01-17  
维护约定：每次对话结束后，将“对话精华”追加到本文末尾，沉淀可执行的下一步与资源索引。

---

## 总览

### 1. 目标与定位

- 目标：在前端主线不掉队的前提下，掌握可用于求职展示的 Agent 能力（工具调用 / 工作流编排 / RAG / 评估与迭代），做出可演示项目与可写进简历的产出。
- 定位：前端 + AI 应用工程（偏产品落地），不强求训练模型，重点在“用好模型 + 工程化 + 可验证效果”。

### 2. 能力地图（按求职价值排序）

1) LLM 应用基础：提示词结构化、上下文管理、流式输出、函数调用/工具调用、错误与重试  
2) Agent 核心：任务分解、规划与执行、工具选择、记忆（短期/长期）、反思与自我纠错（受控）  
3) RAG：向量检索、分块与召回、重排序、引用与可追溯、知识更新策略  
4) 评估与迭代：离线用例集、自动化回归、成本/延迟监控、幻觉与安全约束  
5) 工程化：权限隔离、日志与可观测性、速率限制、缓存、会话持久化、多租户（可选）


## 学习路线

### 3. 推荐学习路线（4 周可落地版本）

#### 第 1 周：能做出一个“能用的聊天应用”
- 前端：Vite/Next.js 任一 + 流式 UI（SSE / fetch streaming）+ 会话管理
- 后端：一个轻量 API 层（Node/Serverless）封装模型调用、重试、超时、限流
- 产出：可演示的 Chat UI + 可配置 System Prompt + 基础日志

#### 第 2 周：工具调用（Function Calling）+ 受控 Agent
- 重点：把“工具”做成可测试的函数（搜索/计算/读写文件/数据库查询等），让模型只能在白名单工具里行动
- 产出：一个“任务助手”Agent（例如：生成学习计划、整理笔记、检查简历要点）+ 工具调用轨迹可视化

#### 第 3 周：RAG（知识库问答 / 文档助手）
- 重点：文档切分、向量库、召回策略、答案可追溯（引用段落/文件）、更新与删除
- 产出：个人知识库助手（支持上传 Markdown/PDF/网页抓取的简化版）

#### 第 4 周：评估与产品化（为求职加分的部分）
- 重点：建立 20-50 条用例集，做自动化评测（正确性/引用覆盖/成本/延迟），并在 UI 展示指标
- 产出：项目 README + Demo 视频脚本 + 简历项目描述（STAR）

### 附录 H：纯前端（Vue 基础）到“前端 + Agent”学习路线（12 周 / 3 个月）

> 适用人群：你这种“前端在学（Vue 更熟、React 在入门）+ 0 Agent 实战”。  
> 学习目标：3 个月内做出 1 个可上线的 PhotoCoach Agent Demo，并能在面试里讲清楚“系统怎么可控、怎么评估、怎么取舍”。  
> 学习原则：先做出闭环，再逐层加深；任何“底层概念”都必须落到项目中的一个可见功能/一次可复现的验证。

#### H0. 你需要掌握到什么程度（别吓自己）
- React/Next：能写中等复杂页面、管理状态、做上传/地图/编辑器、理解服务端路由/接口即可（不用背算法）
- Node/后端：能写 API、懂鉴权/限流/日志/重试/缓存即可（不用深入分布式）
- Agent：能做“受控工具调用 + 状态机工作流 + 可观测 + 可回归”的最小实现即可（不用搞花哨框架）

---

### H1. 12 周路线总览（每周都有可演示产物）

#### Week 1：React/Next “够用就行” + 工程基础
目标：能写页面、能请求、能上手 TS、能跑通 Next 项目。
- 产出：
  - 一个 Next.js + TypeScript + pnpm 项目（能部署到本地）
  - 1 个表单页 + 1 个列表页 + 1 个详情页（路由与数据流跑通）
- 关键点（只学必要的）：
  - React：组件、props、state、hooks（useState/useEffect/useMemo）、受控表单
  - Next：App Router、Server/Client Component 心智、环境变量
  - TS：接口类型、联合类型、可选字段（够用即可）

#### Week 2：做出“可用 UI 骨架”（为 AI 功能铺路）
目标：把你项目的核心交互做出来，不涉及 AI。
- 产出：
  - 登录/注册 UI（先不接后端也行）
  - 照片上传 UI（先做选择/预览/进度/错误）
  - 地点列表（空状态/加载态/错误态）
  - Markdown 编辑区（先用一个简单编辑器组件）
- 关键点：
  - 文件上传（分片不做也行，先把体验做顺）
  - 组件拆分与状态管理（不用上很重的库，先用 React 状态/Context）

#### Week 3：Supabase 上云（跨设备的“数据闭环”）
目标：让你的产品“真的能用”，数据不在本地。
- 产出：
  - Supabase Auth：邮箱/密码登录可用
  - Storage：照片直传 + 公开访问链接可用
  - Postgres：保存地点/照片元数据/总结文档
- 关键点：
  - 公开桶策略：公开读，但上传/删除要鉴权（否则必被刷）
  - 数据模型：地点表、照片表、总结表（先最简）

#### Week 4：地图能力（AMap）+ 地点确认工作流（无 AI 也要可用）
目标：跑通“EXIF→地点→确认→保存”的确定性链路。
- 产出：
  - EXIF 解析（抽取 GPS/时间/镜头）
  - 坐标转换（WGS84→GCJ-02）
  - 地图选点：搜索→定位→拖拽→逆地理→确认
  - 地点卡片：可编辑名称/备注并保存
- 关键点：
  - 状态机思维：无 GPS → 直接进入地图手动流程（先把兜底做稳定）

#### Week 5：LLM 接入（先做“生成 Markdown”，别急着 Agent）
目标：你先把模型调用做正确：流式、错误、重试、限流。
- 产出：
  - Next.js 服务端接口：统一转发到模型（OpenAI/Gemini/Claude 任选其一先跑通）
  - 前端流式展示：边生成边显示，可取消、可重试
  - 生成：把“地点卡片 + 照片元数据”生成 1 版旅行日志 Markdown（可编辑、可保存）
- 关键点：
  - 密钥放服务端
  - 记录 token/耗时（哪怕先写日志）

#### Week 6：工具调用 + JSON Schema（真正开始“Agent 化”）
目标：让模型“只能按你的规则输出”，并能调用你定义的工具。
- 产出：
  - schema 校验：输出不合格 → 自动修复/回退
  - 工具白名单（最小一组）：EXIF 结果读取、地点信息读取、模板渲染、保存总结
  - 轨迹记录：展示“计划→调用工具→生成结果”
- 关键点：
  - 模型只产出“结构化参数/草稿”，执行写入由服务端完成

#### Week 7：工作流状态机（把 Agent 做成产品流程）
目标：把“多步交互”做成可靠流程，而不是纯聊天。
- 产出：
  - 地点候选确认（可先用规则/简单模型提示，不必一开始就视觉识别）
  - 用户确认点：是/否 → 状态转移
  - 失败分支：地图失败、模型失败、用户信息不足的兜底
- 关键点：
  - 每一步都有输入/输出/失败分支/可回退

#### Week 8：多风格生成 + 编辑与导出（产品打磨的关键）
目标：生成内容可用、可二次加工、可分享。
- 产出：
  - 风格切换：小红书风 / 旅行日志（同一份结构化数据，两个模板）
  - Markdown 编辑与版本保存
  - 导出 .md / 分享页（公开访问）
- 关键点：
  - “生成的是初稿”：让编辑变得顺滑（这是前端核心价值）

#### Week 9：RAG（只做最小可用 + 引用）
目标：把“可信度与个性化”做出来，且可追溯。
- 产出：
  - 导入你的摄影笔记（Markdown）→ 切分 → 向量索引
  - 生成时带 citations（引用片段）并在 UI 展示
- 关键点：
  - 别塞长上下文；检索 topK 小而精 + 必须可引用

#### Week 10：评估与回归（你和大多数人拉开差距）
目标：让你“敢改、敢迭代”，不怕把系统改崩。
- 产出：
  - 用例集 ≥ 20 条（覆盖有/无 GPS、歧义地点、两种风格等）
  - 结构回归：schema 必须通过 + 关键字段必须存在 + 引用非空
  - 指标：耗时/失败率/token（最小可用）

#### Week 11：上线与运维（像真正产品）
目标：让面试官看到“你能上线并维护”。
- 产出：
  - Docker 常驻 + 1Panel 反代 + HTTPS（photo.moxiaoshuai.fun）
  - 限流与防滥用：公开读、登录写、上传大小限制
  - 监控：基础日志 + 错误告警（哪怕先用简单方式）

#### Week 12：作品集包装与面试材料（最后一公里）
目标：把你做的东西“讲得出来、证据齐全”。
- 产出：
  - README：架构图（控制器/工具层/记忆层）、关键取舍、风险边界
  - Demo 脚本：3 分钟演示（导入→确认→生成→编辑→分享→轨迹/指标）
  - 简历要点：可量化（延迟/失败率/用例数/功能闭环）

---

### H2. 每天 3-5 小时怎么分配（建议模板）

- 40%：做项目功能（产出可见 UI/接口）
- 30%：补知识（只补当下卡住的那部分）
- 20%：复盘与记录（写到本文档/README：遇到的问题、取舍、数据）
- 10%：回归测试/指标（哪怕先手动跑 5 条）

关键提醒：你最容易掉进“看懂了但没产出”的坑；所以每天必须有一个“可运行、可演示”的小成果。

---

### H3. 你现在立刻能做的 7 天入门冲刺（从 0 到“有手感”）

> 目标：让你不再“一头雾水”，而是知道 Agent 其实就是：状态机 + 工具 + 结构化输出 + 兜底。

- Day 1：Next.js 项目跑起来；做一个表单页（地点/题材/风格）+ 一个结果页（Markdown 展示）
- Day 2：做流式 UI（先用 mock 流式数据也行），实现取消/重试
- Day 3：接通 1 个模型接口（服务端转发），生成一段 Markdown（不追求完美）
- Day 4：把输出改成“外层结构化 + 内层 markdown”，并用 schema 校验
- Day 5：增加 1 个工具（例如 `render_markdown(template, data)`），让模型只输出参数
- Day 6：加 1 个确认点（例如风格/标题是否满意），让用户决定状态转移
- Day 7：写一页 README：你系统的 3 层分解 + 一次完整流程截图（非常加分）

---

### H4. Week 1 详细执行（按天 + 验收标准）

> 你已确认“直接按 12 周路线推进”。Week 1 的目标是：**React/Next 基础够用 + 项目骨架成型 + 你能持续产出**。  
> 约束：每天 3-5 小时；每天结束必须有“可运行、可演示”的结果。

#### Day 1：项目初始化 + 路由骨架
- 做什么：
  - 创建 Next.js（App Router）+ TypeScript + pnpm
  - 建 3 个页面：`/`（入口）、`/places`（地点列表）、`/places/new`（新增地点/导入）
  - 统一布局：顶部导航 + 主内容区
- 验收标准：
  - 本地能跑：`pnpm dev`
  - 3 个页面可互相跳转，刷新不丢路由
  - 页面有基础空状态（无数据时的提示）

#### Day 2：UI 组件与状态管理（先轻量）
- 做什么：
  - 选一个轻量 UI 方案（可先用 Tailwind；也可先纯 CSS，后续再换）
  - 统一表单组件：输入框/按钮/提示/Loading
  - 规范数据流：页面级 state + 少量共享 state（先用 React Context 即可）
- 验收标准：
  - 新增地点表单可输入并在页面内预览“地点草稿卡片”
  - Loading/错误提示组件可复用（至少在 2 个页面用到）

#### Day 3：数据模型草案（不接后端也要先定结构）
- 做什么：
  - 先定义 TypeScript 类型（后续会映射到数据库表）
    - `Place`：地点（名称、坐标、地址、创建者、创建时间）
    - `Photo`：照片（url、exif 摘要、关联地点）
    - `Note/Summary`：总结（风格、markdown、引用、版本）
  - 在前端用 mock 数据跑通“列表→详情→编辑”的 UI 流程
- 验收标准：
  - `/places` 能展示 mock 列表
  - 点进一个地点详情页（可临时用 `/places/[id]`）
  - 详情页能展示“照片列表区 + 总结区（占位）”

#### Day 4：上传 UI（先把体验做顺）
- 做什么：
  - 实现“选择多张照片→预览→移除→上传按钮→进度条”的组件
  - 上传先不接 Storage，先把文件读成预览 URL（本地预览）
  - 设计失败路径：文件过大/格式不支持/用户取消
- 验收标准：
  - 能选多张照片并预览
  - 能移除单张、重新选择
  - 至少 2 类错误提示可触发且可理解

#### Day 5：Markdown 编辑与预览（为“生成后可编辑”铺路）
- 做什么：
  - 加入 Markdown 编辑器/预览（先简化：textarea + 预览也行）
  - 支持“保存草稿（本地 state）→恢复”
  - 准备风格选择 UI（小红书风/旅行日志，先不接生成）
- 验收标准：
  - 用户能在页面里编辑 Markdown 并看到预览
  - 风格切换会改变“模板占位文案”（哪怕是本地 mock）

#### Day 6：服务端接口雏形（为 Week 5 的 LLM 接入打基础）
- 做什么：
  - 写 1 个 Next.js Route Handler（先做健康检查/echo）
  - 梳理环境变量（`.env.local`）与前后端边界（哪些变量只能在服务端）
  - 约定 API 返回结构（统一 `traceId`、`ok`、`error` 结构）
- 验收标准：
  - 前端能调用你的 `/api/health` 并展示结果
  - API 错误能在前端展示（不是默默失败）

#### Day 7：周复盘（把“学到的”变成“能讲的”）
- 做什么：
  - 写一页“Week 1 周报”（放在 README 或你自己的笔记里都行）
  - 记录：做了什么、卡点是什么、如何解决、下周风险
  - 补 2 个小优化（任何提升体验/可用性的点）
- 验收标准：
  - 你能用 2 分钟讲清楚：项目现在能演示什么、下一周要补什么
  - 代码能运行、页面不崩、基本交互顺滑

---

### H5. 每周复盘模板（建议你每周都写）

- 本周完成了什么（可演示的功能）：
- 本周最难的 1-2 个问题：
- 我做了哪些工程取舍（为什么）：
- 指标/事实（哪怕是粗略）：耗时/失败率/页面性能/调用次数
- 下周计划与风险：


## 项目实战（PhotoCoach Agent）

### 7. 主项目建议（摄影主线，React 作品集）

项目名（暂定）：PhotoCoach Agent（摄影教练 + 拍摄规划）

#### MVP（2 周内可演示）
- 技术选型：Next.js（React 框架），用它完成“产品闭环”（UI + 服务端能力）
- 核心功能 1：拍摄需求 → 可执行拍摄清单（场景、器材、参数建议、构图要点、注意事项）
- 核心功能 2：去过的地方总结（输入行程/地点/照片/笔记 → 生成结构化总结 + 亮点回顾 + 下次建议）
- 工具调用（白名单）：读取 EXIF（上传照片/JSON）、天气/日出日落（可选）、本地笔记检索（简化版）
- 可视化轨迹：展示 Agent 的“计划→调用工具→生成结果”的步骤记录
 
#### 进阶（4-8 周）
- RAG：导入你的摄影笔记/器材清单/课程资料，回答时附“引用片段”
- 可靠性：失败重试、超时降级（无工具时仍可给通用建议）、敏感/不确定提示
- 评估：20-50 条用例集（不同题材/光线/镜头），做自动回归（质量+成本+延迟）

#### 秋招加分点（简历可写）
- 受控 Agent（工具白名单 + 权限隔离 + 轨迹可观测）
- RAG 可追溯（引用 + 更新策略）
- 可量化评估（用例集 + 指标面板）

---

### 9. MVP 关键交互（建议按此实现）

1) 导入照片 → 自动读 EXIF（若无 GPS 则进入“地点推测/手动选点”）
2) 地点确认 → 形成“地点卡片”（名称/坐标/时间/照片集合）
3) 生成“去过的地方总结”→ 选择风格 → 产出 Markdown → 可编辑 → 导出
4) 生成“拍摄规划清单”→ 面向下次出行/下一次拍摄的可执行清单

---

### 12. 2 周 MVP 任务拆解（按天，3-5 小时/天）

#### Week 1：跑通“上传→定位→总结→导出”闭环
- Day 1：工程初始化（Next.js + pnpm）、基础页面/路由、UI 框架选型（先轻量即可）、环境变量方案
- Day 2：Supabase 初始化（Auth/DB/Storage）、邮箱密码登录/注册、基本权限与会话保持
- Day 3：照片上传（直传 Storage）、上传进度/失败重试、生成可访问的公开链接
- Day 4：EXIF 解析（提取时间/相机/镜头/GPS）、无 GPS 的分支处理
- Day 5：坐标链路打通（WGS84→GCJ-02）、高德地图接入（展示照片点位 + Marker 拖拽）
- Day 6：地点搜索与选点（关键词搜索→定位→拖拽微调）、逆地理编码得到地点名、地点确认流程（对/不对）
- Day 7：地点卡片与聚合（同一地点照片分组、按时间排序）、“去过的地方”列表页（基础可用）

#### Week 2：加入 Agent（受控工具调用）+ 文案风格 + 部署
- Day 8：LLM 服务端封装（统一接口：OpenAI/Gemini/Claude 任一先跑通）、流式输出到前端
- Day 9：工具白名单（读取 EXIF/地点信息/行程输入/用户偏好）、结构化输出（JSON schema）与校验
- Day 10：“去过的地方总结”Agent（风格：小红书/旅行日志）、生成 Markdown、编辑器（Markdown）与导出
- Day 11：“拍摄规划清单”Agent（输入：题材/器材/时段/地点），输出结构化清单（可打勾/收藏）
- Day 12：轨迹可视化（展示：计划→调用工具→生成结果）、日志与错误提示（用户可理解）
- Day 13：部署到腾讯云 + 1Panel（Node/容器二选一）、Nginx 反代、域名绑定、HTTPS 证书（Let’s Encrypt）
- Day 14：用例集（≥20 条）+ 回归脚本（手动/半自动均可）、README/截图/演示脚本（面试材料）

---

### 10. 关键技术选型（当前建议）

#### 地图（地点搜索 + 拖拽选点）
- 推荐：高德地图 AMap Web JS API（更贴合国内 POI 搜索与可用性，也满足“搜索→定位→拖拽微调”）
- 关键能力：地点/POI 搜索、Marker 拖拽选点、逆地理编码（坐标→地点名）
- 注意：照片 EXIF GPS 通常是 WGS84；国内地图多为 GCJ-02，需要做坐标转换后再在地图上标点/搜索

#### 云端（跨设备同步）
- 结论：需要上云（手机/电脑跨设备使用）
- 推荐：Supabase（Auth + Postgres + Storage，上手快、社区大、适合做产品 Demo）
- 备选：Vercel Postgres + Blob；或国内生态（腾讯云 CloudBase / 自建）

---

### 13. 部署约束（已确认）

- 面板：1Panel（Linux）
- 包管理：pnpm
- 上云：Supabase（Auth + Postgres + Storage）
- 地图：高德 AMap（仅国内）
- 域名：moxiaoshuai.fun
- 子域名：photo.moxiaoshuai.fun（用于本项目）
- 服务器信息（来自 1Panel）：发行版 ubuntu；内核 5.15.0-113-generic（具体 Ubuntu 版本号待确认）
- 服务器公网 IP：43.140.218.233
- DNS 服务商：腾讯云

---

### 15. 上线操作清单（腾讯云 DNS + 1Panel + HTTPS）

#### 15.1 DNS（腾讯云解析）
- 记录类型：A
- 主机记录：photo
- 记录值：43.140.218.233
- TTL：默认即可（先用 600 秒也行）
- 验证：等待解析生效后，用 `ping photo.moxiaoshuai.fun` 或在线 DNS 查询确认已指向该 IP

#### 15.2 服务器与网络
- 安全组/防火墙：放行入站 TCP 80、443（Let’s Encrypt 的 HTTP 校验需要 80）
- 端口占用：确保 80/443 没被其他服务占用（后续由 1Panel/Nginx 接管）

#### 15.3 1Panel（网站 + 反向代理）
- 新建网站：域名填写 `photo.moxiaoshuai.fun`
- 网站类型：反向代理（或先建静态站点也可，最终都要反代到 Next.js）
- 上游地址：`http://127.0.0.1:3000`（约定 Next.js 服务监听 3000）
- 健康检查：能打开网站首页即通过

#### 15.4 1Panel（HTTPS 证书）
- 申请证书：Let’s Encrypt
- 验证方式：HTTP-01（要求 80 可访问）
- 开启 HTTPS：证书签发后启用强制 HTTPS（可选，但建议开启）

#### 15.5 Next.js 服务常驻（两种常见方式）
- 方式 A（更省事）：Docker 部署（构建镜像并以容器方式常驻，对 1Panel 更友好）
- 方式 B（更传统）：Node + pm2（服务器上 `pnpm build` 后用 pm2 运行 `pnpm start`）

#### 15.6 最小验收
- `https://photo.moxiaoshuai.fun` 可打开（手机网络也能访问）
- 登录/注册可用（Supabase Auth）
- 照片可上传并拿到公开链接（Supabase Storage）

---

### 16. 决策记录（上线常驻方案）

- 默认选择：Docker（更适合 1Panel；依赖隔离、可复现、便于升级回滚）
- 备选：Node + pm2（适合你想更深入理解 Node 部署/进程管理的场景）

#### 已确认（2026-01-17）
- 选择方案：方式 A（Docker）

---

### 17. Docker 上线步骤（命令级，可照做）

目标：在服务器用 Docker 常驻运行 Next.js（监听 3000），由 1Panel/Nginx 反代到 `https://photo.moxiaoshuai.fun`

#### 17.1 代码侧（仓库需要准备的文件）
- `Dockerfile`：用于构建并运行 Next.js
- `.dockerignore`：排除 `node_modules`、构建缓存等
- `.env.example`：列出必须的环境变量（不提交真实密钥）

#### 17.2 服务器侧（1Panel）
- 确认已安装 Docker（1Panel 一般可一键安装/管理）
- 建议创建一个工作目录（如 `/opt/photo-coach/`）用于拉取代码与构建镜像

#### 17.3 构建与运行（两种路径，二选一）

路径 A（推荐，最简单）：服务器直接从 Git 拉代码并构建
- `git clone` 拉取项目代码到服务器
- 在项目目录执行 `docker build -t photo-coach:latest .`
- 运行容器：将容器端口 `3000` 映射到服务器本机 `3000`（或只绑定到 `127.0.0.1:3000`）

路径 B：本地构建镜像 → 推到镜像仓库 → 服务器拉取运行
- 适合：你不想在服务器上装构建依赖、或需要更稳定的发布流程

#### 17.4 1Panel 网站反向代理
- 新建网站：`photo.moxiaoshuai.fun`
- 反向代理上游：`http://127.0.0.1:3000`
- 申请 Let’s Encrypt 证书并启用 HTTPS

#### 17.5 MVP 最小环境变量（建议）
- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- `SUPABASE_SERVICE_ROLE_KEY`（仅服务端用，禁止暴露到前端）
- `NEXT_PUBLIC_AMAP_KEY`

---


## 求职与方法论

### 4. 项目作品集建议（从易到难）

1) 前端“学习助理”Agent（工具调用）
- 输入：学习目标/时间/约束；输出：周计划 + 每日任务卡片
- 亮点：任务拆解、可视化执行轨迹、失败重试与降级策略

2) 个人知识库 RAG（文档助手）
- 输入：项目/课程资料；输出：带引用的答案 + 相关片段 + 置信/不确定提示
- 亮点：可追溯、可更新、离线用例集回归

3) 浏览器工作流 Agent（前端强相关）
- 输入：“帮我把某网站的公开信息整理成表格/总结”
- 工具：Playwright（或浏览器扩展）+ 结构化抽取
- 亮点：把“前端自动化 + Agent”结合成可演示的工作流产品

### 5. 面试表达素材（建议准备）

- 你如何控制 Agent 的边界（白名单工具、权限隔离、超时/重试、拒答策略）
- 你如何降低幻觉（RAG + 引用、先检索后回答、结构化输出校验）
- 你如何评估效果（用例集、自动回归、指标与可观测性）
- 你如何做工程权衡（成本/延迟/稳定性/可维护性）

---

### 19. 求职导向：前端如何系统学 Agent（更容易写进简历）

#### 19.1 你要“学会的”不是 Agent 概念，而是可交付的产品能力
面向秋招，最能打动面试官的不是“我用过 LangChain/xx 框架”，而是你能把模型能力做成“可用、可控、可验证”的产品闭环。对你（前端 + AI）来说，核心是两条线并行：
- 产品落地线（前端强项）：流式对话/生成、多人机交互的任务流、多步表单、上传与预览、地图交互、编辑器、分享页、错误提示与引导
- 工程治理线（后端最小闭环，但你要懂）：鉴权、限流、日志、成本、重试、工具白名单、结构化输出校验、数据/文件存储、可观测与回归

你可以把它理解为：“我不是做聊天机器人，我是在做一个带 AI 能力的产品”。只要能上线可用、体验顺滑、可追踪可复现，哪怕功能不多，也足够成为简历亮点。

#### 19.2 前端 vs 后端学 AI 的侧重点差异（你该怎么取舍）

前端侧重点（体验与可控交互）：
- 交互形态：把 Agent 的过程变成用户看得懂、能介入的流程（确认/选择/编辑/回退），而不是一次性输出
- 信息组织：让输出结构化（卡片、清单、时间线、地点地图、引用片段），降低“看不懂/不信任”的成本
- 失败可用：空状态、无 GPS、无权限、模型报错时的降级路径与引导（用户仍然能完成任务）
- 结果可二次加工：编辑、版本、对比、导出（Markdown/图片）、分享（公开链接）
- 可视化可信度：显示“我基于什么生成的”（EXIF、地点、笔记片段、用户输入）+ 轨迹（计划→工具→结果）

后端侧重点（可靠性与治理）：
- 受控 Agent：工具白名单 + 参数校验 + 权限隔离（哪些数据能读、哪些能写）
- RAG 管线：分块、召回、重排序、引用与更新（不是“塞一堆文档”）
- 稳定性：超时、重试、熔断、降级、缓存（尤其是地理/天气等重复查询）
- 成本与延迟：token 统计、限额、并发限制、结果缓存、按用户/按功能计费（哪怕 MVP 只是记录）
- 观测与评估：请求日志、工具调用轨迹、错误聚类、用例集回归（至少 20 条）

对你来说的最佳策略：
- 你不需要一开始把后端做成“企业级平台”，但必须把“治理的关键点”做出最小实现（能解释、能验证）
- 简历写法要避免“调用 API”，而是强调“受控工具调用 + 可观测 + 可评估 + 可上线”

#### 19.3 学习路径（前端 + Agent 的最短闭环）

建议把学习拆成 5 个层级，每一层都有“可演示产物”：
1) L0：React/Next.js 基础（路由、数据请求、状态管理、表单、组件化、基础工程）  
2) L1：LLM 接入（服务端转发、流式输出、错误处理、会话上下文）  
3) L2：受控工具调用（白名单工具、结构化输出、校验与重试、轨迹可视化）  
4) L3：RAG（只在你需要“基于资料回答”时再上；必须带引用与可追溯）  
5) L4：评估与运营（用例集回归、指标面板、成本/延迟、灰度与降级）

你现在的 PhotoCoach Agent，天然可以覆盖 L1-L4（且和前端交互强相关），是非常适合秋招的主项目。

---

### 20. PhotoCoach Agent 如何“像 Agent”而不是“像聊天”

把它设计成“工作流编排器（Workflow Orchestrator）”，每一步都可验证、可回退、可继续：
1) 导入照片（多张）  
2) 工具：解析 EXIF（时间/镜头/相机/GPS）→ 结构化结果  
3) 若无 GPS：Agent 产出候选地点/区域（给理由与不确定性）→ 用户确认“是/否”  
4) 否：地图搜索 → 定位 → 拖拽微调 → 逆地理编码 → 用户确认  
5) 形成地点卡片（地点名/坐标/时间范围/照片集合/用户备注）  
6) Agent：生成“去过的地方总结”（按风格）→ 输出 Markdown（可编辑）→ 导出/分享  
7) Agent：生成“下次拍摄规划清单”（可勾选/收藏/复用）

关键点：每一步输出都要求“结构化”（例如 JSON Schema），并且在 UI 上有“确认/编辑”入口，让用户成为闭环的一部分，这就是产品化 Agent 的核心。

---

### 21. 技术亮点怎么写进简历（可量化、可验证、可复述）

#### 21.1 受控工具调用（最重要）
- 工具白名单：EXIF 解析、坐标转换、AMap 搜索/逆地理编码、用户笔记检索、总结生成
- 参数校验：对模型输出做 JSON Schema 校验，失败则自动纠错/重试/回退到手动流程
- 权限边界：公开可见 ≠ 可任意写入；上传/删除必须登录；公开分享只读

#### 21.2 结构化输出 + 前端可视化
- 结构化产物：地点卡片、照片列表、总结 Markdown、规划清单（都可保存/复用）
- 轨迹与日志面板：展示“计划→调用了哪些工具→得到哪些中间结果→最终生成了什么”

#### 21.3 稳定性与成本（面试常问）
- 重试与降级：模型失败/地图失败/无 GPS 时仍可完成任务（用户体验不中断）
- 成本记录：按功能统计 token/耗时（哪怕是 MVP 也能展示你有成本意识）
- 缓存策略：地理/逆地理编码/天气等重复请求做缓存，提升速度并降低费用

#### 21.4 评估与回归（拉开差距）
- 用例集：至少 20 条（有 GPS/无 GPS、多地点、多照片、不同风格输出、不同输入质量）
- 回归方式：每次改 Prompt/工具/模板后跑一遍（正确性、结构完整性、失败率、耗时）

---

### 22. 业务思考怎么体现（你“像产品/像业务”）

建议你把业务思考写成一页“产品说明”（README 或 wiki），面试时能讲清楚：

#### 22.1 用户画像与场景
- 摄影爱好者：拍了很多照片但难以整理与复盘
- 旅行记录者：希望快速生成“可发布的总结”，并可持续沉淀地点与经验

#### 22.2 指标（你做了什么、怎么证明有效）
- 导入成功率（照片上传/EXIF 解析成功率）
- 地点确认耗时（从导入到地点卡片确认的时间）
- 生成后编辑率（越高说明你做的是“可编辑的初稿”，符合真实工作流）
- 分享率/导出率（结果是否真的可用）
- 留存（同一用户重复使用的次数/周期）

#### 22.3 关键取舍（为什么这么做）
- 无 GPS：不强行“猜对”，而是给候选 + 让用户确认 + 提供手动兜底（降低幻觉伤害）
- 公开分享：让传播与展示更方便，但写入操作必须鉴权，并提示隐私（位置暴露风险）
- “Agent 不直接替你做决定”：Agent 提供建议与草稿，用户做最终确认与编辑（可控、可信）

#### 22.4 风险与边界（大厂很看重）
- 防滥用：公开分享不代表开放上传；对接口做限流；对大图做大小限制
- 隐私提示：公开分享会暴露地点/时间信息，需提示与可删除

---

### 23. 更底层的 Agent 学习：从“黑箱聊天”到“可控系统”

#### 23.1 先建立一个正确心智模型：LLM 不是“智能体”，它是“概率型代码生成器”
你可以把 LLM 当成一个“在自然语言里工作的 CPU”，但它有几个硬限制：
- **它不会持续思考**：模型每次只是在生成下一段 token；所谓“思考链”只是输出的一种形式，不等于真实执行。
- **它没有真实记忆**：它只能看到你喂给它的上下文（context window）。所谓“记忆”必须由你在系统里实现（数据库/向量库/缓存）。
- **它不会访问现实世界**：所有“看照片/查地点/存数据”的能力都要通过工具调用（tools）接到真实系统上。

因此，真正的 Agent 不是“让模型更聪明”，而是：
> 用工程手段把 LLM 包起来：给它目标、状态、工具、边界、反馈，让它在一个可控的闭环里工作。

#### 23.2 Agent 的最小闭环（Sense → Plan → Act → Observe → Iterate）
一个能工作的 Agent 系统，至少要包含这些“可实现的部件”：
1) **状态 State**：当前任务进度、已收集的信息、用户确认结果、失败原因  
2) **规划 Plan**：下一步要做什么（并不是长篇宏大计划，而是可执行的“下一步”）  
3) **动作 Act**：调用工具/生成结构化输出/提示用户确认  
4) **观察 Observe**：工具返回值、用户反馈、校验结果  
5) **迭代 Iterate**：失败重试/改写参数/换工具/回退到手动路径

你做产品时，建议把它显式地做成“状态机”：
- 每一步都有输入、输出、失败分支、可回退点
- 用户确认是“状态转移条件”，不是聊天中的一句话

#### 23.3 “受控”是 Agent 的灵魂：把模型当作不可信组件
大厂更看重你有没有“工程边界意识”。核心做法：
- **工具白名单**：模型只能调用你给的工具集合，不能随便发请求/读写敏感数据
- **参数校验**：模型输出必须通过 JSON Schema（或 zod）校验；不通过就拒绝执行或触发修复
- **权限隔离**：公开页面只读；写操作必须鉴权；服务端密钥永远不下发到浏览器
- **幂等性**：同一个请求重复执行不应该造成重复写入（避免重试导致脏数据）

你可以把“Agent 是否靠谱”理解为：系统是否能在模型犯错时仍然不出大事故，并能引导用户完成目标。

---

### 24. “工具调用”更底层的设计：工具接口决定上限

#### 24.1 好工具的标准：可测试、可校验、可观测、可复用
每个工具都应该像一个严格的 API：
- 输入参数明确（类型/范围/必填）
- 输出结构稳定（可被 UI 直接消费）
- 错误可分类（可重试/不可重试/需要用户）
- 记录耗时与结果摘要（用于追踪与成本优化）

对 PhotoCoach Agent 来说，你至少会有这些工具（示例拆分方式）：
- `extract_exif(photoUrl|file)` → `{ takenAt, camera, lens, gpsWgs84? }`
- `wgs84_to_gcj02(lat, lng)` → `{ lat, lng }`
- `amap_poi_search(keyword, city?, locationBias?)` → `{ candidates[] }`
- `amap_reverse_geocode(latGcj, lngGcj)` → `{ formattedAddress, poi? }`
- `save_place(placeDraft)` / `save_trip(tripDraft)`（服务端鉴权）
- `render_markdown(template, data)`（生成可编辑初稿）

#### 24.2 为什么必须结构化输出（JSON Schema）
结构化输出解决的是“模型输出不可控”的根因：
- 你可以 **验证**：字段缺失/类型错误立即发现
- 你可以 **回填 UI**：卡片/表单/地图点位都来自结构化字段
- 你可以 **做回归测试**：对比字段变化，而不是肉眼看一段文案

文案生成（小红书风/旅行日志）仍然可以是 Markdown，但建议“外层结构化、内层自由文本”：
- 外层：`{ title, summary, highlights[], pitfalls[], next_time_tips[], markdown }`
- 内层：`markdown` 字符串

#### 24.3 失败分类（你要能讲出来）
面试时非常加分的点：你能把失败分成 3 类并处理：
1) **工具失败**：地图 API 超时/限流 → 重试/缓存/降级  
2) **模型失败**：输出不符合 schema/内容跑偏 → 纠错提示/降低温度/拆步  
3) **数据不足**：无 GPS/无行程信息 → 进入“用户确认/手动补全”流程  

---

### 25. 记忆与 RAG：把“上下文”工程化

#### 25.1 你需要区分三种“记忆”
1) **会话记忆（短期）**：本次对话/本次操作的上下文（放在服务端 session 或数据库）  
2) **用户画像（长期）**：偏好（风格、常去城市、器材、常用镜头）  
3) **知识库（可检索）**：摄影笔记、地点攻略、历史总结（适合向量检索）  

#### 25.2 RAG 不是“加个向量库”，而是一条检索-生成流水线
最小可用的 RAG（足以做简历亮点）包含：
- 文档分块（chunk）：按语义切分，保留标题/来源/时间等元数据
- 召回（retrieve）：向量检索 + 关键词检索（可选）
- 重排序（rerank）：把最相关的片段排到前面（没 rerank 也行，但要能解释取舍）
- 生成（generate）：强制引用（给出引用片段 ID/来源），并在 UI 展示
- 更新策略：新增/替换/删除笔记时同步更新索引

你可以在 PhotoCoach Agent 里把 RAG 用在两件事上：
- “地点总结”引用：引用你自己的笔记片段或历史总结（提升可信度）
- “规划清单”引用：引用器材清单与过往经验（更个性化）

#### 25.3 反直觉但重要：不要把所有东西都塞进上下文
上下文越长 ≠ 越聪明，反而会：
- 变慢、变贵、变乱
- 更容易被无关信息干扰
正确做法是“少量高相关 + 可追溯引用 + 用户可编辑确认”。

---

### 26. 评估与迭代：你和大多数同学拉开差距的地方

#### 26.1 建一个“可复现的用例集”（你未来会感谢现在的自己）
用例集不需要复杂，关键是覆盖真实分支：
- 有 GPS / 无 GPS
- 关键词搜索准确 / 不准确
- 用户确认是 / 否
- 小红书风 / 旅行日志
- 多地点多照片

每条用例记录：
- 输入（照片/地点/行程/偏好）
- 期望输出结构（字段必须齐全）
- 允许差异范围（文案不要求逐字一致，但结构与要点要一致）

#### 26.2 指标（让你更像“能上线的人”）
建议从一开始就记录（哪怕先写到日志里）：
- 延迟：首 token 时间、总耗时
- 成本：token 数/次数（按用户、按功能）
- 失败率：schema 校验失败、工具失败、用户放弃率
- 成功率：地点确认成功率、导出率、分享率

#### 26.3 Prompt 不是玄学：把它当“可版本化的配置”
建议你从 Day 1 就做到：
- Prompt 版本号（v1/v2）
- 变更记录（改了什么、为什么）
- 回归对比（改 prompt 前后，用例集跑一遍）

这样面试时你可以讲：
> 我不是“调一调 prompt”，我是用工程方式迭代一个可控系统。

---

### 27. 大厂通用打法：你不确定投哪家时，做“最大公约数”

你现在“不知道投哪家”完全没问题。大厂通用偏好是相似的：
- **React/Next.js + TypeScript**：主流前端栈
- **端到端交付**：能上线、能运维、能解释取舍
- **可靠性意识**：鉴权、限流、日志、错误分级、降级路径
- **评估意识**：用例集、指标、成本/延迟

你的项目如果能做到：
1) 真实工作流（导入→确认→生成→编辑→分享）  
2) 受控工具调用（schema + 白名单 + 权限）  
3) 可观测可评估（轨迹 + 指标 + 用例回归）  
它就能“适配多数大厂面试官的评价框架”。


---

### 附录 A：更底层更深入的 Agent 学习笔记（前端向）

> 目标：把“听说过 Agent 但一头雾水”的状态，推进到“能设计、能实现、能解释、能评估”的工程能力。

#### A0. 先把名词对齐（否则越学越乱）

- `LLM`：生成 token 的模型，本身不具备执行能力与记忆。
- `Tool`：你写的受控函数/API，让系统能读 EXIF、查地图、存数据库、检索文档。
- `Agent/Orchestrator`：控制器，决定何时问用户、何时调用哪个工具、何时生成结果。
- `Memory`：状态与长期信息的存储与检索（DB/缓存/向量库），不是“把历史全塞 prompt”。
- `RAG`：检索增强生成（Retrieve-then-Generate），本质是一条检索流水线，不是“装个向量库”。
- `Evaluation`：用例集 + 指标 + 回归，让效果能被讨论与复现。

你会发现：真正“像 Agent”的系统，至少由 3 层组成：
1) 控制器（状态机/工作流）  
2) 工具层（严格 API）  
3) 记忆层（可持久化、可检索）  

---

### 附录 B：工具调用（Function Calling）与 JSON Schema（把模型拴住）

#### B1. 你要解决的根问题：模型输出的不可控性
模型最危险的不是“答错”，而是：
- 给出看似合理但不可验证的内容（幻觉）
- 输出结构不稳定导致前端/工具执行崩溃
- 在不该写入的时候写入（权限边界被突破）

所以你的系统要把模型当作“不可信组件”：
- 只允许在白名单工具里行动
- 只接受通过 schema 校验的参数
- 把敏感执行放在服务端，并做鉴权与审计

#### B2. Schema 设计的工程范式（建议你照着做）

原则 1：字段越少越好，但必须覆盖 UI/流程需要的“控制字段”
- 例：地点确认需要 `confidence`、`candidates[]`、`reasoning_summary`
- 例：总结需要 `highlights[]`、`pitfalls[]`、`next_tips[]`、`markdown`

原则 2：枚举优先于自由文本
- 风格：`xiaohongshu | travel_log`
- 操作：`ask_user_confirm | call_tool | finalize`

原则 3：把“可选自由文本”放在最后一个字段（避免污染结构）
- `markdown` 可以自由，但外层结构必须稳定

原则 4：输入输出都要有版本号
- `schema_version: "v1"`
- 后面改字段时你能兼容旧数据、能跑回归

#### B3. 工具颗粒度：别太大，也别太碎
经验法则：一次工具调用完成一件“可测试的事”。
- 太大：`generate_everything()` → 不可控、不可测、不可复用
- 太碎：每个字段都一个工具 → 交互成本高、延迟高

PhotoCoach 常见工具拆分（建议）：
- 确定性工具：EXIF 解析、坐标转换、Markdown 渲染
- 外部依赖工具：AMap 搜索、逆地理编码
- 写入工具：保存地点/照片集合/总结（必须鉴权）

#### B4. 参数校验失败后的“自修复回路”（非常加分）
你可以实现一个简单但有效的闭环：
1) 模型输出 JSON  
2) schema 校验失败 → 生成“错误摘要”（缺字段/类型错/越界）  
3) 把错误摘要回喂模型：只允许它修复 JSON（不允许重写任务）  
4) 连续失败 2 次 → 回退为“让用户补信息/手动流程”  

你能把这套讲清楚，面试官基本会默认你具备“可上线思维”。

#### B5. 工具调用的安全边界（必须掌握）
- 服务端密钥（如 `SERVICE_ROLE_KEY`）永远不出服务端
- 公开不等于可写：公开页面可读，写操作要登录 + 限流
- 危险动作（删除/发布覆盖）二次确认（最好由前端确认按钮触发，不由模型自作主张）
- 工具层拒绝“把文档内容当指令”（prompt injection 防护的最后防线）

---

### 附录 C：RAG 全链路（从“能答”到“可信、可追溯”）

#### C1. 什么时候上 RAG（别为了简历硬上）
你上 RAG 的理由必须是“需求驱动”：
- 要个性化（基于你的笔记/器材/历史地点）
- 要引用依据（提升可信度、减少幻觉）
- 要可更新（知识会变，不能每次手工改 prompt）

如果需求只是通用建议，先用工具调用 + 状态机就足够。

#### C2. 最小 RAG：你应该能画出这张流程图并实现简化版
`Ingest → Chunk → Embed/Index → Retrieve → (Rerank) → Compose Context → Generate w/ Citations → Log/Eval`

其中每一步你都要回答一个“工程问题”：
- Chunk：切多大？怎么保留来源？
- Retrieve：topK 取多少？要不要混合检索（关键词 + 向量）？
- Context：怎么把检索结果拼进 prompt 才不污染指令？
- Citations：怎么把引用返回给 UI 展示？
- Update：新增/删除笔记如何同步索引？

#### C3. Chunking（切分）深水区：为什么它决定召回上限
你可以用三个维度来调：
- 语义完整性：一个 chunk 能表达完整观点吗？
- 可定位性：引用时用户能快速回到原文吗？
- 成本：chunk 越多索引越大，检索越慢

摄影笔记很实用的策略：
- 先按标题/小节切（自然结构）
- 超长小节再按段落切
- 每个 chunk 附带元数据：城市、景点、题材、镜头、时间范围、标签

#### C4. Hybrid Search（混合检索）很适合“地名/器材型号”
向量检索擅长语义，但地名/型号/专有名词经常关键词更准。
因此你可以做：
- 先关键词过滤（city/location/gear）
- 再向量召回（更省、更准）

#### C5. 引用（citations）是你区别于“聊天应用”的关键
你只要做到：
- 生成输出里返回引用 chunk 的 `id/source/title`
- UI 展示引用片段（可展开）
就能大幅提升可信度，也让你能调试“召回是否正确”。

#### C6. RAG 的典型坑（提前知道就赢一半）
- 噪声召回：同名地点/简称 → 用元数据过滤 + 候选确认
- 冲突知识：不同笔记观点不同 → 输出冲突并提示“按当前条件选 A/B”
- 指令污染：检索内容夹带“忽略规则” → 明确“文档是内容不是指令” + 工具层兜底

---

### 附录 D：评估与回归（把效果变成事实）

#### D1. 为什么评估是“入门门槛”，不是“高级选修”
没有评估，你的迭代是玄学：
- 改 prompt 可能变好也可能变坏，你不知道
- 加工具/加 RAG 后，失败率/延迟/成本可能飙升，你不知道

#### D2. 用例集（Test Set）怎么做才有用
你的用例集要覆盖“分支”，不是覆盖“内容”：
- 有 GPS / 无 GPS
- 候选地点用户确认 是 / 否
- 地图搜索一击命中 / 歧义多个候选
- 小红书风 / 旅行日志
- 多地点多照片

每条用例最少记录：
- 输入摘要（可以不存真实照片，存 EXIF 抽取结果/描述）
- 期望结构（字段必须齐全）
- 容许差异（文案可变，但要点必须覆盖）

#### D3. 三类指标（你要能背出来并解释）
可靠性：
- schema 通过率、工具失败率、重试次数、降级次数

体验：
- 首 token 时间、总耗时、用户确认步数、中断率

成本：
- token 数、缓存命中率、外部 API 次数、按用户/按功能统计

#### D4. 回归自动化（从轻到重）
轻量（你现在就能做）：
- 发送固定输入 → 验证 schema + 关键字段存在 + 引用非空

中等（求职很加分）：
- 对“结构化输出字段”做 diff（比较 v1/v2 的覆盖率）

更重（以后再做）：
- LLM-as-judge：让模型按标准打分（需要防偏差与校准）

---

### 附录 E：Agent 设计模式（你会在文章里反复看到的“套路”）

#### E1. ReAct（思考/行动交替）的工程化版本
要点：每一步只做一件事（问用户/调工具/产出结构化结果），不要让模型“一次做完所有事”。
落地：你用状态机限制步数与动作类型，避免无限循环。

#### E2. Plan-and-Execute（先计划后执行）
适合复杂任务，但注意：
- “计划”必须可执行、可分步验证
- 计划不是越长越好，长计划经常是幻觉

在 PhotoCoach 里，计划可以非常短：
- “先提取 EXIF → 如果有 GPS 就逆地理 → 否则给候选并让用户确认 → 最后生成总结”

#### E3. 人机协作（Human-in-the-loop）是产品化的关键
你做“确认点”越清晰，Agent 就越可靠：
- 候选地点列表由用户点选（比模型自己拍板靠谱）
- 生成的 Markdown 让用户编辑（比模型自信输出靠谱）

---

### 附录 F：再多学一点（你未来会用到的“系统级思考”）

#### F1. 采样与确定性：为什么同样输入会得到不同输出
核心参数：
- `temperature`：越高越发散，越低越稳定
- `top_p`：另一种控制随机性的方法

工程建议：
- 结构化输出/工具参数生成：用低温（更稳定）
- 文案创作：可适当提高温度，但外层结构保持稳定

#### F2. 缓存策略：既省钱又提速
适合缓存的东西：
- 逆地理编码结果、地点搜索结果（同一关键词/同一坐标）
- RAG 的检索结果（同一查询）
- 模型输出（同一输入、同一版本、同一参数）

注意：缓存必须带版本号（prompt/schema/tool 变了就要失效）。

#### F3. 多模型路由（你有 GPT/Gemini/Claude 的优势怎么用）
你可以用“路由器思维”：
- 默认用性价比最高的模型
- 结构化校验失败/需要更强推理时升级到更强模型
- 失败则降级（不阻塞用户完成任务）

这件事本质是产品思维：成本与效果的平衡，而不是追求最强模型。

#### F4. 观察性（Observability）：为什么大厂在意
你至少要能回答：
- 这次生成为什么慢？慢在模型还是慢在地图？
- 失败发生在哪一步？重试了几次？用户卡在哪一步？

最小实现：
- 每次请求的 traceId
- 工具调用记录（工具名、参数摘要、耗时、结果摘要、错误码）
- 模型调用记录（耗时、token、版本）

---


## 对话精华（汇总）

### 6. 对话精华（持续追加）

#### 2026-01-17
- 你是大三，主攻前端开发；希望结合 AI 热潮学习 Agent 技术以提升就业竞争力。
- 规划方向：优先走“前端 + LLM 应用工程 + 受控 Agent + RAG + 评估”的落地路线，目标是做出可演示作品集。

#### 2026-01-17（补充）
- 技术现状：Vue 较熟；React 正在入门；Node.js 了解但需要工程化实战强化。
- 时间与目标：每天可投入 3-5 小时；目标是今年秋招进大厂，希望 Agent 项目成为简历亮点。
- 作品偏好：更倾向做“产品型 Demo”，且想结合兴趣方向（音乐/美食/摄影）。
- 资源与预算：可用 GPT/Gemini/Claude；预算几百美元，且可能使用公益站免费 API（需注意稳定性与限额）。
- 当前困惑：不确定“前端要怎么系统学习 AI/Agent”，需要可执行的学习路径与里程碑。

#### 2026-01-17（主线确认）
- 主技术栈：选择 React（因大厂偏好），计划用 3 个月边学边做项目；基于 Vue 基础迁移学习。
- 主项目方向：摄影（作为作品集主线）。
- 目标岗位：前端 + AI 应用（未来可扩展到全栈 Node）。

#### 待确认（下次对话优先回答）
1) 你的前端技术栈：React/Next.js/Vue/Node 熟练度如何？  
2) 你每周可投入学习的时间（小时）与目标时间线（1 个月/3 个月/6 个月）？  
3) 你更偏向：做产品 Demo（应用）还是做工程底层（框架/工具）？  
4) 你是否能稳定使用某个大模型 API（或本地模型）？预算范围如何？  

#### 下次对话新增 3 个关键确认
5) 你希望主项目用 Vue 还是顺便用 React/Next.js（更贴近部分大厂栈）？  
6) 你更想做哪一个兴趣方向的主 Demo：音乐 / 美食 / 摄影（只能选 1 个作为主线）？  
7) 你目标岗位更偏：前端开发 / 前端 + AI 应用 / 全栈（Node）？  

#### 已确认（2026-01-17）
5) React  
6) 摄影  
7) 前端 + AI（未来可转全栈）  

---

### 8. 对话精华（继续追加）

#### 2026-01-17（MVP 定稿）
- 框架选择：决定用 Next.js（为了更贴近大厂常见栈，也更容易做出“前端+AI”的完整产品闭环）。
- MVP 重点：以“规划清单”为核心输出，同时支持“去过的地方总结”（偏摄影/旅行记录的产品形态）。

#### 2026-01-17（地点录入与总结输出细化）
- 地点录入优先级：
  - 优先：从照片 EXIF 获取地理位置（GPS 坐标）。
  - 其次：由 Agent 基于照片内容推测地点（给出候选地点/区域），让用户确认“是否在这里拍的”。
  - 兜底：用户手动输入；支持地图选点（搜索 → 定位到大致范围 → 拖动/缩放精确选点；搜索支持更充分关键词以直接命中拍摄地点）。
- 总结输出与编辑：
  - 输出风格可选：小红书风 / 旅行日志（后续可扩展更多风格）。
  - 生成后支持二次编辑（所见即所得或 Markdown 编辑均可）。
  - 导出格式：Markdown（.md）。

---

### 11. 对话精华（继续追加）

#### 2026-01-17（地图与云端）
- 地图：需求是“地点搜索 + 拖拽微调选点”，默认推荐高德地图（AMap Web JS API）；注意 EXIF(WGS84) → 地图(GCJ-02) 的坐标转换。
- 存储：明确选择上云以支持跨设备；默认推荐 Supabase（Auth + Postgres + Storage）作为 MVP 云后端。

#### 2026-01-17（使用范围确认）
- 使用范围：只考虑国内用户与国内可用性，因此地图方案保持高德（AMap）。

#### 2026-01-17（登录与部署）
- 登录方式：邮箱 + 密码（Supabase Auth 默认方案，适合 MVP）。
- 部署平台：使用自有腾讯云服务器（VPS），不走 Vercel。
- 服务器配置评估：4 核 4G / 系统盘 40G 对 MVP 够用；前提是“照片文件走对象存储（Supabase Storage）直传”，不要把大图长期落在服务器系统盘。

#### 2026-01-17（上传/存储/证书决策）
- 照片上传路径：选择“客户端直传 Supabase Storage”（减少服务器带宽与磁盘压力，更稳定可扩展）。
- 数据库存储：业务数据存 Supabase Postgres（云端数据库，不在你的电脑里）；对象存储（Supabase Storage）只放照片/导出文件等大对象。
- HTTPS 证书：当前无证书；上线需域名 + Nginx 反代 + Let’s Encrypt（或腾讯云 SSL）获取证书后启用 HTTPS。

#### 2026-01-17（域名与公开策略）
- 域名：已具备，可直接规划 Nginx 反代 + HTTPS 上线流程。
- 照片可见性：选择“公开”；实现建议为 Storage 公共桶 + 可分享页面，但“上传/删除”仍需登录权限以避免滥用。

---

### 14. 对话精华（继续追加）

#### 2026-01-17（部署信息补齐）
- 你在腾讯云 VPS 上使用 1Panel；系统为 Ubuntu（内核 5.15），将项目绑定到子域名 `photo.moxiaoshuai.fun`。
- 下一步目标：完成 DNS 解析 → 反代 → HTTPS 证书 → Next.js 服务常驻，形成可对外访问的 Demo。

---

### 18. 对话精华（继续追加）

#### 2026-01-17（部署方案最终确认）
- 你已确认 Next.js 常驻部署选 Docker（方式 A），以配合 1Panel 做反代与 HTTPS，上线目标域名为 `photo.moxiaoshuai.fun`。

---

#### 2026-01-17（学习困惑与面试表达）
- 你当前更需要“答疑解惑”：作为前端如何学习 Agent 才更利于找工作；前端/后端学 AI 的侧重点差异；如何在 PhotoCoach Agent 项目里融入 Agent；如何体现技术深度与业务思考。
- 作品集表达方向：用“可落地产品闭环 + 可观测可评估的受控 Agent + 真实用户流程（导入-确认-生成-编辑-分享）”来证明能力，而不是只展示调用模型。

### 附录 G：对话精华（继续追加）

#### 2026-01-17（学习深挖诉求）
- 你希望系统性补齐 Agent 的底层知识：工具调用与 schema、RAG 全链路、评估与回归，并希望内容越细越好、能引发思考与行动。  

---


